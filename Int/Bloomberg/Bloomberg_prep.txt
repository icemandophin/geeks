Write an exception safe constructor wrapper that puts the constructed object in a unique_ptr:

exception-safety in a component means that it can proceed with reasonable behavior and prevent potential leak, even when an exception is thrown during its execution.
// shared_ptr version
class SPResourceClass {
private:
    unique_ptr<int> m_p;
    unique_ptr<char> m_q;
public:
    SPResourceClass() : m_p (make_unique<int>()), m_q (make_unique<char>()) { }
    // Implicitly defined is OK for these members,
    // unique_ptr will clean up and avoid leaks regardless.
};

compiler may is allowed to evaluate the above expressions in the following order:

Evaluate the expression new Foo()
Evaluate the expression new Bar()
Construct the std::unique_ptr<Foo> temporary from the result of 1.
Construct the std::unique_ptr<Bar> temporary from the result of 2.

// old-style new/delete version
class NDResourceClass {
	private:
	    int*   m_p;
	    float* m_q;
	public:
	    NDResourceClass() : m_p(0), m_q(0) {
	        m_p = new int;
	        m_q = new float;
	    }

	    ~NDResourceClass() {
	        delete m_p;
	        delete m_q;
	    }
	    // Potential leak! When a constructor emits an exception,
	    // the destructor will not be invoked.
};

Create a data structure that can represent a deck of cards and implement "shuffle" functionality: (Fisher–Yates shuffle)

public class Card {
    private final int rank;
    private final int suit;
    // Kinds of suits
    public final static int DIAMONDS = 1;
    public final static int CLUBS    = 2;
    public final static int HEARTS   = 3;
    public final static int SPADES   = 4;
    // Kinds of ranks
    public final static int ACE   = 1;
    public final static int DEUCE = 2;
    public final static int THREE = 3;
    public final static int FOUR  = 4;
    public final static int FIVE  = 5;
    public final static int SIX   = 6;
    public final static int SEVEN = 7;
    public final static int EIGHT = 8;
    public final static int NINE  = 9;
    public final static int TEN   = 10;
    public final static int JACK  = 11;
    public final static int QUEEN = 12;
    public final static int KING  = 13;

    public Card(int rank, int suit) {
        this.rank = rank;
        this.suit = suit;
    }

    public int getSuit() {
        return suit;
    }

    public int getRank() {
        return rank;
    }
}
public class Deck {
    /**
     * An array of 52 or 54 cards.  A 54-card deck contains two Jokers,
     * in addition to the 52 cards of a regular poker deck.
     */
    private Card[] deck;

    /**
     * Keeps track of the number of cards that have been dealt from
     * the deck so far.
     */
    private int cardsUsed;

    /**
     * Constructs a regular 52-card poker deck.  Initially, the cards
     * are in a sorted order.  The shuffle() method can be called to
     * randomize the order.  (Note that "new Deck()" is equivalent
     * to "new Deck(false)".)
     */
    public Deck() {
    	// Just call the other constructor in this class.
        this(false);
    }

    /**
     * Constructs a poker deck of playing cards, The deck contains
     * the usual 52 cards and can optionally contain two Jokers
     * in addition, for a total of 54 cards.   Initially the cards
     * are in a sorted order.  The shuffle() method can be called to
     * randomize the order.
     * @param includeJokers if true, two Jokers are included in the deck; if false,
     * there are no Jokers in the deck.
     */
    public Deck(boolean includeJokers) {
        if (includeJokers)
            deck = new Card[54];
        else
            deck = new Card[52];
        int cardCt = 0; // How many cards have been created so far.
        for ( int suit = 0; suit <= 3; suit++ ) {
            for ( int value = 1; value <= 13; value++ ) {
                deck[cardCt] = new Card(value, suit);
                cardCt++;
            }
        }
        if (includeJokers) {
            deck[52] = new Card(1,Card.JOKER);
            deck[53] = new Card(2,Card.JOKER);
        }
        cardsUsed = 0;
    }

    /**
     * Put all the used cards back into the deck (if any), and
     * shuffle the deck into a random order.
     */
    public void shuffle() {
        for ( int i = deck.length-1; i > 0; i-- ) {
        	// generate random number between [0, i]
            int rand = (int)(Math.random()*(i+1));
            // if rand == i => keep the same
            // otherwise swipe a[rand] and a[i]
            Card temp = deck[i];
            deck[i] = deck[rand];
            deck[rand] = temp;
        }
        cardsUsed = 0;
    }
    // explain of Math.random()
    int randomWithRange(int min, int max)
	{
	   int range = (max - min) + 1;
	   return (int)(Math.random() * range) + min;
	}

    /**
     * As cards are dealt from the deck, the number of cards left
     * decreases.  This function returns the number of cards that
     * are still left in the deck.  The return value would be
     * 52 or 54 (depending on whether the deck includes Jokers)
     * when the deck is first created or after the deck has been
     * shuffled.  It decreases by 1 each time the dealCard() method
     * is called.
     */
    public int cardsLeft() {
        return deck.length - cardsUsed;
    }

    /**
     * Removes the next card from the deck and return it.  It is illegal
     * to call this method if there are no more cards in the deck.  You can
     * check the number of cards remaining by calling the cardsLeft() function.
     * @return the card which is removed from the deck.
     * @throws IllegalStateException if there are no cards left in the deck
     */
    public Card dealCard() {
        if (cardsUsed == deck.length)
            throw new IllegalStateException("No cards are left in the deck.");
        cardsUsed++;
        return deck[cardsUsed - 1];
        // Programming note:  Cards are not literally removed from the array
        // that represents the deck.  We just keep track of how many cards
        // have been used.
    }

    /**
     * Test whether the deck contains Jokers.
     * @return true, if this is a 54-card deck containing two jokers, or false if
     * this is a 52 card deck that contains no jokers.
     */
    public boolean hasJokers() {
        return (deck.length == 54);
    }

} // end class Deck

Given a string of parenthesis, brackets, and square brackets, check if everything matches:
    public boolean isValidParenthesis(String s) {
        Stack<Character> stk = new Stack<Character>();

        for(char c : s.toCharArray())
        {
            switch(c)
            {
                case '(':
                    stk.push(')');
                    break;
                case '{':
                    stk.push('}');
                    break;
                case '[':
                    stk.push(']');
                    break;
                case ')':
                    if(stk.isEmpty() || stk.pop() != c)
                    {
                        return false;
                    }
                    break;
                case ']':
                    if(stk.isEmpty() || stk.pop() != c)
                    {
                        return false;
                    }
                    break;
                case '}':
                    if(stk.isEmpty() || stk.pop() != c)
                    {
                        return false;
                    }
                    break;
                default:
                    break;
            }
        }

        return stk.isEmpty();
    }

Given a list of distinct integers, count the number of ordered pairs of integers
in the list such that the first is larger than the second:
Leetcode_493

Write a program to find the intersection of two arrays. For example, when array1 = {2, 11, 5, 4}
and array2 = {11, 1, 3, 2}, the output should be {2, 11}:
Leetcode_349

What data structures will be used while designing an Elevator system：
Priority Queue (detail in design)

For an array of positive and negative integers, return the sequence with largest sum:
Leetcode_53

Binary Search Tree - Get K maximum element
Leetcode_230

Flattening Linked List:
void flattenList(Node node) {
    if (node == null) {
        return;
    }
    Node tmp = null;
    /* Find tail node of first level linked list */
    Node tail = node;
    while (tail.next != null) {
        tail = tail.next;
    }
    // One by one traverse through all nodes of first level
    // linked list till we reach the tail node
    Node cur = node;
    while (cur != tail) {
        // If current node has a child
        if (cur.child != null) {
            // then append the child at the end of current list
            tail.next = cur.child;
            // and update the tail to new last node
            tmp = cur.child;
            while (tmp.next != null) {
                tmp = tmp.next;
            }
            tail = tmp;
        }
        // Change current node
        cur = cur.next;
    }
}

Arrays - Sorting, K largest elements?
Leetcode_215

Check if binary tree is balanced?
Leetcode_110

Least Recently used cache implementation?
Leetcode_146

move all zeros to the end of the array?
Leetcode_283

Say you have an array of version numbers ["1.1.10", "1.2.10.3", "2.1", etc],
sort them?
Leetcode_165

Kth Smallest Element in a BST？
Leetcode_230

Least Recently used cache implementation?
Leetcode_146

a special array, unsorted, don't care about the sequence, make the
deletion operation use constant time. (Hint, if delete a middle item,
pop the last item to fill it)?
swap the target a[i] with last one a[N-1], then decrease array size by one
